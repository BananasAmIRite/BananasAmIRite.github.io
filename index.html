<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Interactive Background</title>
        <style>
            body,
            html {
                margin: 0;
                padding: 0;
                overflow: hidden;
                width: 100%;
                height: 100%;
                background-color: #000;
            }
            canvas {
                display: block;
            }
        </style>
    </head>
    <body>
        <canvas id="backgroundCanvas"></canvas>
        <script>
            const canvas = document.getElementById('backgroundCanvas');
            const ctx = canvas.getContext('2d');

            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            const circles = [];
            const numCircles = 50;
            const maxRadius = 30;
            const minRadius = 5;
            const maxDistance = 100;
            let mouseX = canvas.width / 2;
            let mouseY = canvas.height / 2;

            window.addEventListener('mousemove', (event) => {
                mouseX = event.clientX;
                mouseY = event.clientY;
            });

            class Circle {
                constructor(x, y, dx, dy, radius) {
                    this.x = x;
                    this.y = y;
                    this.dx = dx;
                    this.dy = dy;
                    this.radius = radius;
                    this.minRadius = radius;
                    this.color = `rgba(${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 255}, 0.5)`;
                }

                draw() {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                }

                update() {
                    if (this.x + this.radius > canvas.width || this.x - this.radius < 0) {
                        this.dx = -this.dx;
                    }

                    if (this.y + this.radius > canvas.height || this.y - this.radius < 0) {
                        this.dy = -this.dy;
                    }

                    this.x += this.dx;
                    this.y += this.dy;

                    const distance = Math.hypot(mouseX - this.x, mouseY - this.y);
                    if (distance < maxDistance && this.radius < maxRadius) {
                        this.radius += 1;
                    } else if (this.radius > this.minRadius) {
                        this.radius -= 1;
                    }

                    this.draw();
                }
            }

            function init() {
                for (let i = 0; i < numCircles; i++) {
                    const radius = Math.random() * (maxRadius - minRadius) + minRadius;
                    const x = Math.random() * (canvas.width - radius * 2) + radius;
                    const y = Math.random() * (canvas.height - radius * 2) + radius;
                    const dx = (Math.random() - 0.5) * 2;
                    const dy = (Math.random() - 0.5) * 2;
                    circles.push(new Circle(x, y, dx, dy, radius));
                }
            }

            function drawMorphingEffect() {
                for (let i = 0; i < circles.length; i++) {
                    for (let j = i + 1; j < circles.length; j++) {
                        const distance = Math.hypot(circles[i].x - circles[j].x, circles[i].y - circles[j].y);
                        if (distance < circles[i].radius + circles[j].radius) {
                            const angle = Math.atan2(circles[j].y - circles[i].y, circles[j].x - circles[i].x);
                            const halfDistance = distance / 2;

                            const controlPointX = (circles[i].x + circles[j].x) / 2 + Math.sin(angle) * halfDistance;
                            const controlPointY = (circles[i].y + circles[j].y) / 2 - Math.cos(angle) * halfDistance;

                            ctx.beginPath();
                            ctx.moveTo(circles[i].x, circles[i].y);
                            ctx.quadraticCurveTo(controlPointX, controlPointY, circles[j].x, circles[j].y);
                            ctx.strokeStyle = `rgba(255, 255, 255, ${1 - distance / maxDistance})`;
                            ctx.lineWidth = 2 * (1 - distance / maxDistance);
                            ctx.stroke();
                        }
                    }
                }
            }

            function animate() {
                requestAnimationFrame(animate);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                circles.forEach((circle) => circle.update());
                drawMorphingEffect();
            }

            init();
            animate();
        </script>
    </body>
</html>
